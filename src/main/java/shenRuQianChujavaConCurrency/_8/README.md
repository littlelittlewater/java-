分析ReentrantLock:
public void java.util.concurrent.locks.ReentrantLock.lock()
    获取锁。
    如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。
    如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。
    如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。

平锁保证一个阻塞的线程最终能够获得锁，因为是有序的，所以总是可以按照请求的顺序获得锁。
不公平锁意味着后请求锁的线程可能在其前面排列的休眠线程恢复前拿到锁，这样就有可能提高并发的性能。
这是因为通常情况下挂起的线程重新开始与它真正开始运行，二者之间会产生严重的延时。
因此非公平锁就可以利用这段时间完成操作。这是非公平锁在某些时候比公平锁性能要好的原因之一。



